{"ast":null,"code":"import { forwardRef, Directive, Input, HostBinding, HostListener, ElementRef, ChangeDetectorRef, Renderer2, Optional, Inject, ContentChildren, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// TODO: config: activeClass - Class to apply to the checked buttons\n\n/** @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nconst CHECKBOX_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n\n  /* tslint:disable-next-line: no-use-before-declare */\n  useExisting: forwardRef(\n  /**\n  * @return {?}\n  */\n  () => ButtonCheckboxDirective),\n  multi: true\n};\n/**\n * Add checkbox functionality to any element\n */\n\nlet ButtonCheckboxDirective = /*#__PURE__*/(() => {\n  class ButtonCheckboxDirective {\n    constructor() {\n      /**\n       * Truthy value, will be set to ngModel\n       */\n      this.btnCheckboxTrue = true;\n      /**\n       * Falsy value, will be set to ngModel\n       */\n\n      this.btnCheckboxFalse = false;\n      this.state = false;\n      this.onChange = Function.prototype;\n      this.onTouched = Function.prototype;\n    } // view -> model\n\n    /**\n     * @return {?}\n     */\n\n\n    onClick() {\n      if (this.isDisabled) {\n        return;\n      }\n\n      this.toggle(!this.state);\n      this.onChange(this.value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      this.toggle(this.trueValue === this.value);\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    get trueValue() {\n      return typeof this.btnCheckboxTrue !== 'undefined' ? this.btnCheckboxTrue : true;\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n\n    get falseValue() {\n      return typeof this.btnCheckboxFalse !== 'undefined' ? this.btnCheckboxFalse : false;\n    }\n    /**\n     * @param {?} state\n     * @return {?}\n     */\n\n\n    toggle(state) {\n      this.state = state;\n      this.value = this.state ? this.trueValue : this.falseValue;\n    } // ControlValueAccessor\n    // model -> view\n\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    writeValue(value) {\n      this.state = this.trueValue === value;\n      this.value = value ? this.trueValue : this.falseValue;\n    }\n    /**\n     * @param {?} isDisabled\n     * @return {?}\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.isDisabled = isDisabled;\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n\n  }\n\n  ButtonCheckboxDirective.ɵfac = function ButtonCheckboxDirective_Factory(t) {\n    return new (t || ButtonCheckboxDirective)();\n  };\n\n  ButtonCheckboxDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ButtonCheckboxDirective,\n    selectors: [[\"\", \"btnCheckbox\", \"\"]],\n    hostVars: 3,\n    hostBindings: function ButtonCheckboxDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function ButtonCheckboxDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-pressed\", ctx.state);\n        ɵngcc0.ɵɵclassProp(\"active\", ctx.state);\n      }\n    },\n    inputs: {\n      btnCheckboxTrue: \"btnCheckboxTrue\",\n      btnCheckboxFalse: \"btnCheckboxFalse\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([CHECKBOX_CONTROL_VALUE_ACCESSOR])]\n  });\n  return ButtonCheckboxDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * Truthy value, will be set to ngModel\n   * @type {?}\n   */\n  ButtonCheckboxDirective.prototype.btnCheckboxTrue;\n  /**\n   * Falsy value, will be set to ngModel\n   * @type {?}\n   */\n\n  ButtonCheckboxDirective.prototype.btnCheckboxFalse;\n  /** @type {?} */\n\n  ButtonCheckboxDirective.prototype.state;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ButtonCheckboxDirective.prototype.value;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ButtonCheckboxDirective.prototype.isDisabled;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ButtonCheckboxDirective.prototype.onChange;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  ButtonCheckboxDirective.prototype.onTouched;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst RADIO_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n\n  /* tslint:disable-next-line: no-use-before-declare */\n  useExisting: forwardRef(\n  /**\n  * @return {?}\n  */\n  () => ButtonRadioDirective),\n  multi: true\n};\n/**\n * Create radio buttons or groups of buttons.\n * A value of a selected button is bound to a variable specified via ngModel.\n */\n\nlet ButtonRadioDirective = /*#__PURE__*/(() => {\n  class ButtonRadioDirective {\n    /**\n     * @param {?} el\n     * @param {?} cdr\n     * @param {?} renderer\n     * @param {?} group\n     */\n    constructor(el, cdr, renderer, group) {\n      this.el = el;\n      this.cdr = cdr;\n      this.renderer = renderer;\n      this.group = group;\n      this.onChange = Function.prototype;\n      this.onTouched = Function.prototype;\n      this.role = 'radio';\n      this._hasFocus = false;\n    }\n    /**\n     * Current value of radio component or group\n     * @return {?}\n     */\n\n\n    get value() {\n      return this.group ? this.group.value : this._value;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set value(value) {\n      if (this.group) {\n        this.group.value = value;\n        return;\n      }\n\n      this._value = value;\n    }\n    /**\n     * If `true` — radio button is disabled\n     * @return {?}\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * @param {?} disabled\n     * @return {?}\n     */\n\n\n    set disabled(disabled) {\n      this.setDisabledState(disabled);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get controlOrGroupDisabled() {\n      return this.disabled || this.group && this.group.disabled ? true : undefined;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get hasDisabledClass() {\n      // Although the radio is disabled the active radio should still stand out.\n      // The disabled class will prevent this so don't add it on the active radio\n      return this.controlOrGroupDisabled && !this.isActive;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get isActive() {\n      return this.btnRadio === this.value;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get tabindex() {\n      if (this.controlOrGroupDisabled) {\n        // Disabled radio buttons should not receive focus\n        return undefined;\n      } else if (this.isActive || this.group == null) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get hasFocus() {\n      return this._hasFocus;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    toggleIfAllowed() {\n      if (!this.canToggle()) {\n        return;\n      }\n\n      this.value = this.uncheckable && this.btnRadio === this.value ? undefined : this.btnRadio;\n\n      this._onChange(this.value);\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onSpacePressed(event) {\n      this.toggleIfAllowed();\n      event.preventDefault();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    focus() {\n      this.el.nativeElement.focus();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    onFocus() {\n      this._hasFocus = true;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    onBlur() {\n      this._hasFocus = false;\n      this.onTouched();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    canToggle() {\n      return !this.controlOrGroupDisabled && (this.uncheckable || this.btnRadio !== this.value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      this.uncheckable = typeof this.uncheckable !== 'undefined';\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    _onChange(value) {\n      if (this.group) {\n        this.group.value = value;\n        return;\n      }\n\n      this.onTouched();\n      this.onChange(value);\n    } // ControlValueAccessor\n    // model -> view\n\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    writeValue(value) {\n      this.value = value;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /**\n     * @param {?} disabled\n     * @return {?}\n     */\n\n\n    setDisabledState(disabled) {\n      this._disabled = disabled;\n\n      if (disabled) {\n        this.renderer.setAttribute(this.el.nativeElement, 'disabled', 'disabled');\n        return;\n      }\n\n      this.renderer.removeAttribute(this.el.nativeElement, 'disabled');\n    }\n\n  }\n\n  ButtonRadioDirective.ɵfac = function ButtonRadioDirective_Factory(t) {\n    return new (t || ButtonRadioDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(forwardRef(\n    /**\n    * @return {?}\n    */\n    () => ButtonRadioGroupDirective), 8));\n  };\n\n  ButtonRadioDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ButtonRadioDirective,\n    selectors: [[\"\", \"btnRadio\", \"\"]],\n    hostVars: 8,\n    hostBindings: function ButtonRadioDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function ButtonRadioDirective_click_HostBindingHandler() {\n          return ctx.toggleIfAllowed();\n        })(\"keydown.space\", function ButtonRadioDirective_keydown_space_HostBindingHandler($event) {\n          return ctx.onSpacePressed($event);\n        })(\"focus\", function ButtonRadioDirective_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"blur\", function ButtonRadioDirective_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"role\", ctx.role)(\"aria-disabled\", ctx.controlOrGroupDisabled)(\"aria-checked\", ctx.isActive)(\"tabindex\", ctx.tabindex);\n        ɵngcc0.ɵɵclassProp(\"disabled\", ctx.hasDisabledClass)(\"active\", ctx.isActive);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      disabled: \"disabled\",\n      uncheckable: \"uncheckable\",\n      btnRadio: \"btnRadio\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([RADIO_CONTROL_VALUE_ACCESSOR])]\n  });\n  /** @nocollapse */\n\n  return ButtonRadioDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  ButtonRadioDirective.prototype.onChange;\n  /** @type {?} */\n\n  ButtonRadioDirective.prototype.onTouched;\n  /**\n   * Radio button value, will be set to `ngModel`\n   * @type {?}\n   */\n\n  ButtonRadioDirective.prototype.btnRadio;\n  /**\n   * If `true` — radio button can be unchecked\n   * @type {?}\n   */\n\n  ButtonRadioDirective.prototype.uncheckable;\n  /** @type {?} */\n\n  ButtonRadioDirective.prototype.role;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ButtonRadioDirective.prototype._value;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ButtonRadioDirective.prototype._disabled;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ButtonRadioDirective.prototype._hasFocus;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ButtonRadioDirective.prototype.el;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ButtonRadioDirective.prototype.cdr;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ButtonRadioDirective.prototype.renderer;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ButtonRadioDirective.prototype.group;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst RADIO_CONTROL_VALUE_ACCESSOR$1 = {\n  provide: NG_VALUE_ACCESSOR,\n\n  /* tslint:disable-next-line: no-use-before-declare */\n  useExisting: forwardRef(\n  /**\n  * @return {?}\n  */\n  () => ButtonRadioGroupDirective),\n  multi: true\n};\n/**\n * A group of radio buttons.\n * A value of a selected button is bound to a variable specified via ngModel.\n */\n\nlet ButtonRadioGroupDirective = /*#__PURE__*/(() => {\n  class ButtonRadioGroupDirective {\n    /**\n     * @param {?} cdr\n     */\n    constructor(cdr) {\n      this.cdr = cdr;\n      this.onChange = Function.prototype;\n      this.onTouched = Function.prototype;\n      this.role = 'radiogroup';\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get value() {\n      return this._value;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set value(value) {\n      this._value = value;\n      this.onChange(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get tabindex() {\n      if (this._disabled) {\n        return null;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    writeValue(value) {\n      this._value = value;\n      this.cdr.markForCheck();\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /**\n     * @param {?} disabled\n     * @return {?}\n     */\n\n\n    setDisabledState(disabled) {\n      if (this.radioButtons) {\n        this._disabled = disabled;\n        this.radioButtons.forEach(\n        /**\n        * @param {?} buttons\n        * @return {?}\n        */\n        buttons => {\n          buttons.setDisabledState(disabled);\n        });\n        this.cdr.markForCheck();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    onFocus() {\n      if (this._disabled) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const activeRadio = this.getActiveOrFocusedRadio();\n\n      if (activeRadio) {\n        activeRadio.focus();\n      } else {\n        /** @type {?} */\n        const firstEnabled = this.radioButtons.find(\n        /**\n        * @param {?} r\n        * @return {?}\n        */\n        r => !r.disabled);\n\n        if (firstEnabled) {\n          firstEnabled.focus();\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    onBlur() {\n      if (this.onTouched) {\n        this.onTouched();\n      }\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    selectNext(event) {\n      this.selectInDirection('next');\n      event.preventDefault();\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    selectPrevious(event) {\n      this.selectInDirection('previous');\n      event.preventDefault();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n    /**\n     * @private\n     * @param {?} direction\n     * @return {?}\n     */\n\n\n    selectInDirection(direction) {\n      if (this._disabled) {\n        return;\n      }\n      /**\n       * @param {?} currentIndex\n       * @param {?} buttonRadioDirectives\n       * @return {?}\n       */\n\n\n      function nextIndex(currentIndex, buttonRadioDirectives) {\n        /** @type {?} */\n        const step = direction === 'next' ? 1 : -1;\n        /** @type {?} */\n\n        let calcIndex = (currentIndex + step) % buttonRadioDirectives.length;\n\n        if (calcIndex < 0) {\n          calcIndex = buttonRadioDirectives.length - 1;\n        }\n\n        return calcIndex;\n      }\n      /** @type {?} */\n\n\n      const activeRadio = this.getActiveOrFocusedRadio();\n\n      if (activeRadio) {\n        /** @type {?} */\n        const buttonRadioDirectives = this.radioButtons.toArray();\n        /** @type {?} */\n\n        const currentActiveIndex = buttonRadioDirectives.indexOf(activeRadio);\n\n        for (let i = nextIndex(currentActiveIndex, buttonRadioDirectives); i !== currentActiveIndex; i = nextIndex(i, buttonRadioDirectives)) {\n          if (buttonRadioDirectives[i].canToggle()) {\n            buttonRadioDirectives[i].toggleIfAllowed();\n            buttonRadioDirectives[i].focus();\n            break;\n          }\n        }\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    getActiveOrFocusedRadio() {\n      return this.radioButtons.find(\n      /**\n      * @param {?} button\n      * @return {?}\n      */\n      button => button.isActive) || this.radioButtons.find(\n      /**\n      * @param {?} button\n      * @return {?}\n      */\n      button => button.hasFocus);\n    }\n\n  }\n\n  ButtonRadioGroupDirective.ɵfac = function ButtonRadioGroupDirective_Factory(t) {\n    return new (t || ButtonRadioGroupDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  ButtonRadioGroupDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ButtonRadioGroupDirective,\n    selectors: [[\"\", \"btnRadioGroup\", \"\"]],\n    contentQueries: function ButtonRadioGroupDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, ButtonRadioDirective, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.radioButtons = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function ButtonRadioGroupDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"focus\", function ButtonRadioGroupDirective_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"blur\", function ButtonRadioGroupDirective_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        })(\"keydown.ArrowRight\", function ButtonRadioGroupDirective_keydown_ArrowRight_HostBindingHandler($event) {\n          return ctx.selectNext($event);\n        })(\"keydown.ArrowDown\", function ButtonRadioGroupDirective_keydown_ArrowDown_HostBindingHandler($event) {\n          return ctx.selectNext($event);\n        })(\"keydown.ArrowLeft\", function ButtonRadioGroupDirective_keydown_ArrowLeft_HostBindingHandler($event) {\n          return ctx.selectPrevious($event);\n        })(\"keydown.ArrowUp\", function ButtonRadioGroupDirective_keydown_ArrowUp_HostBindingHandler($event) {\n          return ctx.selectPrevious($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"role\", ctx.role)(\"tabindex\", ctx.tabindex);\n      }\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([RADIO_CONTROL_VALUE_ACCESSOR$1])]\n  });\n  /** @nocollapse */\n\n  return ButtonRadioGroupDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  ButtonRadioGroupDirective.prototype.onChange;\n  /** @type {?} */\n\n  ButtonRadioGroupDirective.prototype.onTouched;\n  /** @type {?} */\n\n  ButtonRadioGroupDirective.prototype.role;\n  /** @type {?} */\n\n  ButtonRadioGroupDirective.prototype.radioButtons;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ButtonRadioGroupDirective.prototype._value;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ButtonRadioGroupDirective.prototype._disabled;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ButtonRadioGroupDirective.prototype.cdr;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet ButtonsModule = /*#__PURE__*/(() => {\n  class ButtonsModule {\n    /**\n     * @return {?}\n     */\n    static forRoot() {\n      return {\n        ngModule: ButtonsModule,\n        providers: []\n      };\n    }\n\n  }\n\n  ButtonsModule.ɵfac = function ButtonsModule_Factory(t) {\n    return new (t || ButtonsModule)();\n  };\n\n  ButtonsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ButtonsModule\n  });\n  ButtonsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return ButtonsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ButtonsModule, {\n    declarations: [ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective],\n    exports: [ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective, ButtonsModule, CHECKBOX_CONTROL_VALUE_ACCESSOR as ɵa, RADIO_CONTROL_VALUE_ACCESSOR$1 as ɵb, RADIO_CONTROL_VALUE_ACCESSOR as ɵc }; //# sourceMappingURL=ngx-bootstrap-buttons.js.map","map":null,"metadata":{},"sourceType":"module"}